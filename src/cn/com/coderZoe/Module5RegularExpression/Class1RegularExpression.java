package cn.com.coderZoe.Module5RegularExpression;

/**
 * @author yhs
 * @date 2020/5/2 14:18
 * @description
 */
public class Class1RegularExpression {
    /**
     * 正则表达式
     * 用于文本的复杂处理
     * 大部分编程语言、数据库、文本编辑器、开发环境都支持正则表达式
     *
     * 正则表达式语法1：
     * 普通字符：字母数字汉字下划线以及没有特殊定义的标点符号都是普通字符 表达式中的普通字符 在匹配一个字符串的时候 匹配与之相同的字符
     * 简单的转义字符 \n(换行) \t(制表符) \\(\)
     * \^ \$ \. \? \+ \* \|
     *
     * 正则表达式语法2：
     * 标准字符集合：能够与多种字符进行匹配(注意大小写区分 大小写是相反的意思)
     * /d(匹配0-9任意一个数字 \D非数字) \w(任意一个字母或数字或下划线 \W非数字字母下划线) \s(匹配一个空格制表换行等空白字符 \S非空白符) .(小数点可以匹配任意一个除换行符的字符 [\s\S] 匹配任意字符 包括换行符)
     *
     * 正则表达式语法3:
     * [] 方括号匹配方式 能够匹配方括号中任意一个字符(类似于对匹配结果做或运算)
     * 如：[ab5@] 匹配a或b或5或@中任意一个字符(a||b||5||@)
     * [^abc]方括号内的尖括号是取反的意思 即匹配abc之外的任意一个字符(!(a||b||c))
     * [a-z] 方括号内的下划线是"至"的意思 比如a-z是匹配a到z的任意一个字符
     * [^a-f0-9]匹配a-f和0-9之外的任意一个字符
     * 正则表达式的特殊符号被包含到中括号中除-和^外其余则失去意义(如$在中括号中就代表其本身 不具有特殊意义)
     * 正则表达式标准字符集合除小数点外 如果你被包含于中括号 自定义字符集合将包含该集合(翻译一下：就是像\d \w这种中括号也是认的 但小数点的特殊意义中括号不认)
     * 如: [\d.\-+]将匹配数字小数点(不再有特殊意义)-+
     *
     * 正则表达式语法4：
     * 量词：修饰匹配次数的特殊符号
     * {n} 表达式重复n次 如\d{5} 连续匹配5个任意数字 (\d\w){10}匹配数字+数字或字符或下划线 这种组合连续2次
     * {m,n} 表达式重复至少m次 至多n次 默认模式是贪婪模式(按越多越好匹配 尽量按最多匹配)
     * {m,n}? 非贪婪模式 按匹配最少算
     * {m,}最少匹配m次 也是越多越好
     * ? 匹配表达式0或一次(类似于{0,1}) 可以是0次 也即不匹配
     * + 匹配至少一次(类似于{1,}) a\d+b (ab a777b a45678000b)
     * * 表达式不出现或出现任意次 相当于{0,}
     *
     * 正则表达式语法5:
     * 字符边界:标记匹配的不是字符而是位置 符合某种条件的位置
     * ^ 字符串开始的地方匹配 ^a 匹配字符串的开头为a的字符串
     * $ 与字符串结束的地方匹配    a$ 匹配字符串结束的位置为a的字符串
     * \b 匹配一个单词边界 前面的字符和后面的字符不全是\w \babcdef\b(匹配abcdef的字符 并且a的左右侧不全是/w f的左右侧也不全是\w)
     *
     * 正则表达式语法6:
     * 匹配模式:
     * IGNORECASE 忽略大小写模式 默认情况下正则表达式区分大小写
     * SINGLELINE 单行模式 整个文本看作一个字符串 只有一个开头一个结尾
     * MULTILINE 多行模式 每一行都是一个字符串 都有开头和结尾 如果只想匹配整个字符串的开头和结尾 就不能用^和$ 要用\A和\Z
     *
     * 正则表达式语法7:
     * 选择符和分组
     * | 左右两边表达式或的关系 匹配左边或右边 a|b 匹配a或b
     * 分组:捕获组和非捕获组
     * 捕获组:() 小括号的用途
     * (1).在被修饰次数的时候 括号中的表达式可作为整体被修饰(expression){m} 组织结构
     * (2).反向引用(\nnn) 每一对括号会分配一个编号 使用()的捕获根据左括号的顺序从1开始自动编号 通过反向引用 可以对分组已捕获的字符串进行引用
     * 如:([a-z]{2})\1 这句话的意思是说 先捕获a-z的两个字符 捕获到具体字符后 再对已捕获字符进行引用 匹配结果如:abab czczcz amam(重复捕获内容)
     * \n代表小括号n编码捕获的内容(编码以左括号为准) (1(2)(3))(4)
     * 非捕获组:捕获组一般会在内存中进行保存 当文本较大时可能会占用较大内存 所以当在一些表达式中不得不使用()但又不需要保存()中的匹配内容 这时可以使用非捕获组来抵消副作用
     * 表达式(?:expression)
     *
     * 正则表达式语法8:
     * 预搜索(零宽断言/环视):
     * 零宽度:指对位置的匹配 如:\b ^ $ 判断某一位置前面或后面应该如何
     * 1.(?=expression) 断言出现的位置后面能匹配表达式expression
     * 如: [a-z]+(?=ing) 匹配所有以ing结尾的单词 如watching going aing等 +代表{1,} [a-z]+(?=\d+) 所有以1至多个数字结尾的单词
     * expression本身不会被匹配 只匹配他之前的东西 如上面的ing例子 只匹配watch go a等
     * 2.(?<=expression) 断言出现的位置前面能匹配表达式expression
     * 如: [a-z]+(?<=ing) 以ing开头的单词
     * 3.(?!expression) 断言出现的位置后面不能匹配表达式expression
     * 如:[a-z]+(?!\d+) 不能以数字结尾的任意单词
     * 4.(?<!expression) 断言出现的位置前面不能匹配表达式expression
     * 如:[a-z]+(?<!ing) 不以ing开头的单词
     *
     *
     *
     */
    public static void main(String[] args) {
        /**
         * 匹配电话号码
         * 1.电话号码由数字和-组成
         * 2.电话号码为7-8位
         * 3.如果电话号码中包含区号 那么区号为3-4位 首位是0
         * 4.区号用-和其他部分隔开
         * 5.移动电话号码为11位
         * 6.11位移动电话号码的第一位和第二位为"13" "15" "18"
         */

        String telPhone = "0\\d{2,3}-\\d{7,8}|1[3,5,7,8]\\d{9}";

        /**
         * 匹配电子邮箱
         * 1.用户名:字母数字中划线下划线组成
         * 2.@
         * 3.网址 小数点和字母组成
         * 4.小数点
         * 5.组织域名:2-4位字母组成
         * 不区分大小写
         */
        String email = "[\\w\\-]+@[\\da-zA-Z]+(\\.[A-Za-z]{2,4}){1,2}";
    }
}
